### 간단 정리
- [정보처리기사 필기 강의](https://www.youtube.com/channel/UCczcbg-Pv6pzn9Zp9lQ3WZA)
- [필기 정보처리기사 소프트웨어 설계 1과목](#1과목)
- [필기 정보처리기사 소프트웨어 개발 2과목](#2과목)
- [정보처리기사 실기 2020년 1회 기출](#1회)
- [정보처리기사 실기 2020년 2회 기출](#2회)
- [정보처리기사 실기 2020년 3회 기출](#3회)
---
### 1과목

소프트웨어 생명 주기

- 소프트웨어 개발 과정을 단계별로 나눈 것

폭포수 모델

- 각 단계를 한 번씩만 거침 (되돌릴 수 없음)
- 단계별 철저한 검증 필요
- 메뉴얼 작성 필요

프로토타입 모델 (원형 모델)

- 기능적 인터페이스 중심으로 견본 개발 후 최종 개발 추 후 발견 될 오류 방지

나선형 모델 

- 계획 - 분석(검증) - 개발 - 평가(오류 방지)의 단계를 반복 폭포수와 프로토타입의 장점을 흡수하여 점진적 개발
- 대규모 소프트웨어 개발에 용이

애자일 모델

- 요구사항 반영 및 고객과의 의사소통 빈도를 높이는 것이 목표.
- 여러 개발 방법을 아우르는 모델

---

스크럼 기법 

- 팀 중심, 제품 책임자, 스크럼 마스터, 개발팀으로 구성

제품 책임자(PO)

- 의사 결정자
- 백로그의 우선순위 지정

스크럼 마스터

- 일일 회의 주관, 개발 가이드

개발팀 : 개발자 뿐 아니라 디자이너, 테스터 등 모든 인원

프로세스 -

- 백로그 : 요구사항을 우선순위에 따라 모아놓은 목록
- 계획 회의 : 스프린트 일정 수립, 개발자 별로 스프린트 백로그 작성
- 스프린트 진행 : 할 일, 진행 중, 완료
- 일일 회의 : 스크럼 마스터 주도, 소멸차트 활용
- 검토 회의 : 주별, PO 주도, 백로그 업데이트
- 회고 : 지난 일정 되돌아보기, 개선점 찾기

---

XP 기법

- 짧고 반복적인 개발 주기, 고객의 적극적 참여를 통한 가시성 향상
- 소규모 인원의 개발 프로젝트에 효과적

핵심가치 (피-존-용-단-소)

- 피드백, 존중, 용기, 단순화, 소통

개발 프로세스 -

- 사용자 스토리 : 고객의 요구사항
- 릴리즈 계획 수립 : 부분과 전체의 개발 일정 수립
- 스파이크 : 기술 및 기능확인을 위해 간단히 만드는 프로그램
- 이터레이션 : 릴리즈를 좀 더 세분화 한 단위
- 승인 검사 : 부분 소프트웨어가 릴르즈 되면 고객이 직접 평가
- 소규모 릴리즈 : 릴리즈 별로 고객의 피드백 확인 가능

---

 시스템 파악 : 시스템 개발 범위를 명확하게 설정 (구기인아소하네)

- 시스템 구성 : 기간(주요) 업무와 지원 업무의 주요 기능 파악
- 시스템 기능 : 주요 기능별 세부 기능들을 계층형으로 표시
- 시스템 인터페이스 : 주고받는 데이터의 형식, 프로토콜 파악
- 아키텍처 구성 : 주요 업무 시스템의 구성과 동작원리를 표현
- 소프트웨어 구성 : 종류 및 라이선스의 적용방식과 비용
- 하드웨어 구성 : 서버의 주요 사양과 수량, 이중화 적용 여부
- 네트워크 구성 : 구성도 작성. 물리적 위치, 보안 취약점, 유지보수

---

개발 기술 환경 파악

- 운영체제 : 시스템 자원 관리, 하드웨어 제어를 위한 인터페이스
    - 고려사항 : 주변기기 지원여부
- DBMS : 데이터베이스 관리를 위한 시스템, 종속성과 중복성 해결,  DB에 대한 모든 권한과 책임이 있음
    - 고려사항 : 상호 호환성, 데이터 이중화
- WAS : 동적 콘텐츠 처리를 위한 미들웨어, DB서버와 연동
    - 미들웨어 : 서버와 클라이언트 중간에 위치, 클라이언트 대신 복잡한 처리를 하기 위함
    - 고려사항 : 다양한 옵션
- 공통 고려사항 : 가용성, 성능, 비용, 기슬지원
- 오픈소스 : 라이선스 종류, 기술 지속 가능성, 사용자 수

---

요구사항 정의/분석/확인

요구사항 : 서비스에 대한 설명 및 제약조건

- 기능 : 기능 자체
- 비기능 : 기능의 품질, 제약사항
- 사용자 : 쉬운 표현 사용
- 시스템 : 개발자 입장, 전문용어

요구사항 개발 프로세스 : 도출(의사소통) → 분석 → 명세(문서화) → 확인

- 분석 : 타당성 조사, 특정 기준으로 분류
    - 개념 모델링 : 단순화, 개념적 표현, 객체 간 관계와 종속성 분석
    - 협상 : (기능과 비 기능, 필요 자원, 서로)의 요구사항이 충돌하는 경우
    - 정형 분석 : 마지막 단계, 구문과 의미를 갖는 언어 사용, 수학적 기호로 표현
- 확인 : 검증
    - 검토 : 일반적, 고객 대표 포함
    - 모델 검증 : 정적(논리적) 검증, 실행안함
    - 프로토 타이핑 : 지속적인 프로토타입 작성, 사전 피드백
        - 단점 : 프로토 타입에만 집중, 비용부담, 과대평가
    - 인수 테스트 : 사용자 입장에서 요구사항 체크(계획 필요)

---

UML(Unified Modeling Language)

1. 물리적인 자원의 위치를 표시하는 것으로 구현 단계에서 사용되는 것은? → 배치 다이어그램
2. 사물의 종류 중 (구조, 행동, 주해)를 제외한 나머지 하나는? → 그룹
3. (시퀀스, 상태, 배치, 활동)중, 동적인 행위를 표현하기 위한 것이 아닌 것은? → 배치 다이어그램
4. UML 다이어그램 중, 구현 단계에서 사용하기 적절한 것은? → 컴포넌트, 배치
5. 의존, 실체화 관계에서 처럼, 일시적인 관계를 표현할 때 사용되는 선은? → 점선 화살표
6. 다중도 표현에서 ('다수', '또는')에 해당하는 기호는? *와 ..
7. 자동차와 열쇠의 관계를 표현하기 가장 적절한 관계는? → 포함관계

---

사용자 인터페이스

사용자 인터페이스 3가지 분야 : 제어, 구성, 기능

사용자 인터페이스의 특징
- 만족도에 큰 영향을 끼치기 때문에, 가장 많이 변경된다.
- 편리성과, 가독성, 이해도를 높인다.
- 최소한의 노력으로 결과를 얻을 수 있도록 한다.
- 소프트웨어 아키텍처를 숙지해야 한다.

사용자 인터페이스의 구분 : CLI(텍스트), GUI(마우스), NUI(말, 행동)

사용자 인터페이스의 기본 원칙 : 직관, 유효, 학습, 유연

사용자 인터페이스의 설계 지침
- 사용자 중심, 일관성, 단순성, 결과 예측 가능, 표준화, 접근성, 명확성, 가시성, 오류 발생 해결

---

UI 설계 도구

표준 및 지침에 따라 UI를 제작하기 위해선 설계도가 필요

설계도는 결과물에 대해 미리보기 기능을 함

와이어프레임(wireframe) : 뼈대(레이아웃) 배치, 화면 단위

목업(mockup) : 실제화면과 유사. 기능 구현 아님.

스토리보드(storyboard) : 와이어프레임 + 콘텐츠 설명, 이동경로, 작업지침서 활용 (설명은 세부적 작성 필요)

프로토타입(prototype) : 인터렉션 적용 (동적인 형태)

유스케이스(use case) : 사용자 요구사항(기능적)을 다이어그램 형식으로 문서화, 각각의 유스케이스에 대한 명세서 작성

---

UI 요구사항 확인

개인별 인터뷰를 통해 가능한 많은 사람들과 인터뷰를 진행한다.

인터뷰를 통해 사업적, 기술적인 요구사항을 명확히 한다.

리서치를 진행하기 전 인터뷰를 해야 보다 효율적이다.

활동사항을 정의할 때는 서로 협의를 통해 진행한다.

요구사항의 작성은 사용자 중심으로 하여 개발에 편리하도록 한다.

UI 요구사항 중 가장 먼저 데이터에 대한 정리를 진행한다.
- 데이터 : 가장먼저 확인, 특성 기반 정리
- 기능 : 무엇을 실행하는지? 동사형으로 정리
- 품질 : 품질, 서비스, 감성적인 부분
- 제약 : 비용과 데드라인, 규제 등

정황 시나리오는 완성 된 서비스를 상상하며 최대한 자세히 작성한다.

요구사항은 정황 시나리오를 토대로 작성한다.

---

품질 요구사항

SW품질에 대한 국제 표준 지침 = ISO/IEC 9126

기능 : 적절한 기능이 정확하게 + 호환, 보안
- 적절성, 정확, 상호운용, 보안, 호환

신뢰 : 결함에도 문제 없이.
- 성숙, 회복, 고장허용

사용 : 얼마나 쉽고 편한지
- 이해, 학습, 운용, 친밀

효율 : 한정된 시간, 자원으로 많은 일 처리
- 시간, 자원

유지보수 : 개선 및 확장
- 분석, 변경, 시험, 안정

이식 : 다른 환경에서 적응
- 적용, 설치, 대체, 공존

---

UI 프로토타입 제작 및 검토

UI 프로토타입 : 동적인 형태(실제 동작하는 것처럼)의 테스트 모델, 필수 기능을 포함, 간단하게, 실 사용자 테스트로 기능 검증

장단점 : 이해와 오류발견이 쉽다 / 자원소모 생략 가능성

종류
- 페이퍼 : (손으로)-저렴, 즉시, 간단
- 디지털 : (SW로)-결과와 비슷, 테스트 및 수정, 어려움

고려사항
- 계획 : 목적 - 환경 - 핵심UI - 인원 - 검증 - 해결 - 가이드
- 작성 : 범위확인 - 목표확인 - 자원확인

제작단계 : 요구사항분석 - 요구사항작성(프로토타입) - 사용자 테스트 및 수정 - 사용자 피드백 및 승인
- 사용자 테스트 / 피드백 부분은 반복될 수 있다.

---

UI 설계서 작성

표지 : 프로젝트(시스템) 명

개정이력 : 초안작성 이후 변경할 때마다 버전이 증가

요구사항 정의서 : 요구사항 별 적용여부 기록

시스템 구조 : 전체 시스템(사용자, 관리자 등)의 구조 설계

사이트 맵 : 전체 콘텐츠 메뉴별 구성 + 표 형태로 작성

프로세스 정의서 : 사용자 입장에서 작업이 진행되는 순서도

화면설계 : 각화면별로 표지 + 스토리보드

---

UI 유용성평가, 상세설계, 감성공학

유용성평가
- 뜻 : 사용자 입장에서 얼마나 유용한지
- 실행(기능) : 불필요, 중복, 불편, 어려운
- 결과(평가) : 즉각적이지 않은 피드백, 결과 이해, 파악이 어려움

상세설계
- 시나리오 : 순서도나 계층구조로 작성
- 일반규칙 : 기능, 구조, 인터렉션, 예외처리 (이후 세부기능 정의)
- 기대효과 : 긍정적인 문장과 단어 (완전, 일관, 이해 등...)

감성공학
- HCI(Human Computer Interface) : 편리하고 안전한 시스템 개발(최적의 UX가 목표)
- UX(User eXperience) : 시스템 이용경험, 주관적임(객관적인 UI편리성과 반대)
- 감성공학 : 감성적, 인간친화적 개발

---

소프트웨어 아키텍처

SW 아키텍처
- 뜻 : 기본 구조, 개발 기반
- 역할 : 품질유지, 원칙, 지침
- 모듈 : 부품

기본원리
- 모듈화 : 유지관리에 좋음. (많으면 통합비용 ↑, 적으면 개발비용 ↑)
- 추상화 : 포괄적 개념, 구체화 하기 위해 필요. 가성비. 구조파악 용이.
- 단계적 분해 : 하향식. 추상화의 반복으로 더 많은 단계의 분해 가능.
- 정보은닉 : 접근금지. 별도의 인터페이스 사용. 유지보수에 용이. 

품질속성
- 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성
- 비지니스 측면 : 시장 적시성, 비용과 혜택, 시스템 수명
- 아키텍처 측면 : 무결성, 정확성, 완결성, 구축가능성

설계과정 : 목표 - 시스템타입 - 아키텍처패턴 - 시스템구체화 - 검토

---

아키텍처 패턴

레이어 : 상/하위 계층끼리 상호작용

P2P : 서버와 클라이언트 역할 변경 가능

모델-컨트롤러-뷰 : 대화형 어플리케이션에 적합

서버-클라이언트 : 1:다 / 항시대기 / 독립적 기능

파이프-필터 : 재사용, 확장, 변환, 동기화, 버퍼링

블랙보드 : 공유 데이터 검색, 인식, 식별 

---

모듈

모듈
- 뜻 : 모듈화 된 기능. 서브루틴, 서브시스템 등오로도 불림 / 재사용 가능 ▶
- 독립성 판당 : 약한 결합도와 강한 응집도. 품질과 련관.

결합도
- 뜻 : 모듈간 상호 의존(영향을 미치는) 정도
- 종류
    - 자료 : 데이터
    - 스탬프 : 자료구조
    - 제어 : 제어요소
    - 외부 : 외부참조
    - 공유 : 공통 데이터
    - 내용 : 내부 직접 참조

응집도
- 뜻 : 정보은닉 개념 확장, 내부 요소들끼리의 관련 종ㄷㅎ
- 종류
    - 기능 : 단일 연결
    - 순차 : 이전 출력 - 다음 출력
    - 통신 : 동일 입출력 다른 기능
    - 절차 : 다수의 기능을 순차적으로
    - 논리 : 유사한 기능 모음

팬 - 인 : 해당 모듈을 제어하는. 들어오는 화살표
팬 - 아웃 : 해당 모듈을 제어하는. 나가는 화살표

공통모듈
- 명세기법
    - 정확 : 필요성
    - 명확 : 비중의적
    - 완전 : 필요한 모든 것
    - 일관 : 중복 방지
    - 추적 : 출처/관계 파악

---

코드 / 디자인 패턴

코드 
- 순차 : 1, 2, 3, 4, 5, ...
- 블록 : A학과 : 1001 ~ 1010
- 10진 : 1317
- 그룹분류 : 1 - 04 - 002
- 연상 : LG-OLED50
- 표의숫자 : R 300-400-600

디자인 패턴
- 생성 패턴 : 캡슐화, 유연성
    - Abstract Factory : 객체 생성코드가 상위 클래스에 존재, 하위(구체화) 클래스가 받아 씀
    - Factory Method : 객체 생성코드를 하위 클래스에서 구체화. 상위 클래스는 인터페이스만 제공
    - Builder : 분리 된 인스턴스를 조합하여 객체 생성
    - Prototype : 원본 복제, 비용 저렴
    - Singleton : 클래스 내 인스턴스 하나뿐임을 보장. 동시 참조 불가능

- 구조 패턴 : 복잡한 구조의 시스템 개발에 필요
    - Adapter : 일치하지 않는 인터페이스 변환
    - Bridge : 추상층(기능)과 구현층(구체화)을 분리하여 독립적 확장
    - Composite : 트리구조 구성. 단일과 복합 개체 구분없이 다룸
    - Decorator : 기능 추가위해 다른 객체를 덧붙임
    - Facade : 서브 클래스들의 통합 인터페이스를 제공(wrapper객체)하는 상위 클래스 구성
    - Flyweight : 다수의 유사 객체 생성이 필요할 때 최대한 공유해서 사용 (메모리 절약)
    - Proxy : 접근이 어려운 객체에 접근할 수 있도록 인터페이스 역할 수행
 
- 행위 패턴 : 상호작용, 책임 분배
    - Chain of Responsibility : 둘 이상의 객체가 연결(chain)되어 책임이 차례로 넘어감
    - Command : 명령어 캡슐화(추상과 구체). 로그에 기록
    - Interpreter : 문법 표현 정의. 맞춤법 검사
    - Iterator : 접근이 잦은 객체는 동일한 인터페이스 사용하도록, 순차접근
    - Mediator : 복잡한 상호작용 캡슐화, 결합도 ↓
    - Memento : 특정 시점의 상태 객체화. 되돌리기
    - Observer : 이벤트 발행과 구독. 상태 변화 전달
    - State : 상태에 따라 동작을 다르게
    - Strategy : 동일 계열 알고리즘 상호교환. 독립적 사용
    - Template Method : 상위에서 인터페이스 정의. 하위에서 구체화(유지보수)
    - Visitor : 처리 기능을 별도의 클래스로 구성

---

시스템 인터페이스 요구사항 분석/검증

요구사항 명세서 구성
- 이름, 시스템, 범위(내용), 방식, 송신 데이터, 인터페이스 주기, 고려사항


요구사항 분석 절차
- 요구사항 선별 : 별도의 인터페이스 요구사항 목록 제작
- 자료 준비 : 시스템 인터페이스 요구사항과 관련된 자료 준비
- 요구사항 분류 : 기능적 / 비기능적 요구사항으로 분류
- 분석 및 수정 : 내용을 추가 및 수정 / 세분화 / 우선순위 부여

요구사항 검증
- 요구사항 검토 계획 : 기준과 방법, 참여자, 체크리스트, 관련자료, 일정 등
- 검증 방법 : 동료검토, 워크스루(사전검토 후 회의), 인스펙션(검토 전문가), 프로토타입 제작 / 관련 툴 사용
- 검증항목 : 완전성(누락여부), 일관성(충돌여부), 명확성(이해여부), 기능성, 검증가능성, 추적가능성, 변경용이성

---

인터페이스 시스템 식별, 송/수신 데이터 식별

인터페이스 시스템 식별
- 개발 시스템 식별 : 개발하고자 하는 시스템 정보
- 내/외부 시스템 식별 : 개발 시스템과 연계할 내/외부 시스템 정보
- 내/외부 시스템 환경 및 관리 주체 식별 : 운용환경(IP, URL, PORT, ...)과 담당자 정보
- 내/외부 시스템 네트워크 연결 정보 식별 : 인증 및 DB 정보
- 인터페이스 식별 : 시스템과 연계할 시스템 사이의 인터페이스 정보
- 인터페이스 시스템 식별 : 송신, 수신 시스템 구분(대외, 내외 구분)

식별 대상 데이터
- 인터페이스 : 시스템 연계에 필요한 표준 데이터
    - 시스템 공통부 : 연동에 필요함. 인터페이스, 시스템, 코드, 장애 정보 등
    - 거래 공통부 : 송/수신 데이터 처리, 직원, 기기, 매체 정보 등
- 송/수신 데이터 항목
    - 업무 수행에 사용되는 데이터
    - 인터페이스 별로 다름
- 공통코드
    - 공통적으로 사용하는 코드
    - 상태 코드, 오류 코드, 코드 설명 등


송/수신 데이터 식별
- 인터페이스 표준 항목 : 교환범위확인, 인터페이스 표준항목에 대한 송/수신 데이터 식별
- 코드성 데이터 항목 식별
    - 양쪽코드가 동일한 경우 : 공통 코드
    - 양쪽 코드가 다른 경우 : 양쪽 코드 정보 필요
    
---

인터페이스 방법 명세화/설계서 작성

시스템 연계 기술
- DB Link : 기본 제공. DB Link 객체 이용
- API : DB를 읽어오도록 만들어 둔 인터페이스 프로그램
- 연계 솔루션
    - EAI서버와 각 시스템에 설치 된 클라이언트를 통해 데이터 통신
    - 모니터링 및 통제 기능
- Socket : 포트할당, 클라이언트와 연결
- Web Service : SOAP, WSDL, UDDI

통신 유형
- 단방향 : 요청, 응답없음
- 동기 : 요청 및 대기, 응답
- 비동기 : 요청 및 미대기, 응답

처리 유형
- 실시간 방식 : 즉시처리, 예매, 카톡
- 지연처리 방식 : 처리시간 여유, 즉시 처리 시 비용문제, 본인인증 문자
- 배치 방식 : 일괄처리, 모아뒀다가 대량으로 한번에, 세금계산

---

미들웨어 종류

- DataBase(DB)
- Message Oriented Middleware(MOM)
- Object Request Broker(ORB)
- Remote Procedure Call(RPC)
- Web Application Server(WAS)
- Transaction Processing Monitor(TPM)

---

### 2과목

자료구조

선형 - `List`, `Queue`, `Stack`

비선형 - `Tree`, `Graph`

효율적인 프로그램을 작성할 때 가장 우선적인 고려사항은 저장공간의 `효울성`과 실행시간의 `신속성`이다.

자료구조에 따라 프로그램의 `실행시간`이 달라진다.

자료구조는 `자료`의 표현과 그것과 관련된 `연산`이다.

`선형 자료구조`는 순서에 따라 데이터에 접근하고 있는 형태이다.

`배열`은 `동일한 자료형`의 데이터들이 나열되어 있는 구조이다.

배열은 데이터 접근과 처리는 `첨자와 변수`를 이용한다.

배열은 `삽입/삭제` 작업보다 `반복적 데이터 처리`에 적합하다.

배열은 정적인 자료구조로서, `메로리의 낭비`가 발생한다.

[접근요소, 기억공간, 삽입/삭제]
연속 리스트 - 배열(첨자), 효울, 비효율
연결 리스트 - 노드(포인트), 비효율, 효율

`스택`은 자료의 삽입, 삭제가 `한쪽 방향`으로만 이루어진다.

스택은 `가장 나중`에 삽입된 자료가 `가장 먼저` 삭제되는 `후입선출`방식이다.

공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 `오버플로우`가 발생한다.

공간이 비워져 있는 상태에서 데이터가 삭제되면 `언더플로우`가 발생한다.

`큐`는 자료의 삽입, 삭제가 `서로 다른 방향`에서 이루어진다.

`가장 먼저` 삽입된 자료가 `가장 먼저` 삭제되는 `선입선출`방식이다.

Front 포인터는 `가장 먼저` 삽입 된 데이터의 위치를 기억한다.

Rear 포인터는 `가장 마지막에` 삽입 된 데이터의 위치를 기억한다.

`트리`의 맨 위에 있는 노드는 `루트노드`, 맨 아래에 있는 노드는 `터미널 노드`다.

특정 노드의 이전 레벨은 `부모노드`, 다음 레벨은 `자식노드`이다.

동일한 부모노드를 가지고 있는 노드들은 `형제노드`이다.

트리는 `순환을` 하지 않는 그래프의 형태이다.

---

데이터베이스/DBMS/SQL

`논리` 데이터저장소는 데이터 간의 연관성, 제약조건 등을 조직화한 것이다.

`물리` 데이터저장소는 하드웨어적 저장장치에 데이터를 저장한 것이다.

DBMS의 필수 기능 3가지는 `정의`, `조작`, `제어`기능이다.

DBMS의 궁극적인 목표는 종속성을 제거하여 `독립성`을 지키는 것이다.

데이터 `정의어` : 테이블이나 제약사항 등을 변경할 때 사용

데이터 `조작어` : 데이터를 실제로 처리하는데 사용

데이터 `제어어` : 권한, 보안, 백업 등을 정의하는데 사용

`트랜잭션` : 한꺼번에 수행되어야 하는 작업(연산)의 단위 (모음)

트랜잭션 실행 중, 오류가 나면 `롤백`을 실행하여 이전 상태로 되돌리고, 전부 완료되었다면 `커밋`을 실행하여 결과를 실제로 반영한다.

절차형 SQL을 `블록 구조`로 되어 있어 기능별 모듈화가 가능하다.

프로시저와 사용자 정의 함수의 차이는 `리턴 값의 필수 여부`이다.

디버깅은 `주석과 출력문`을 이용하는 것이 일반적이다.

---

통합구분

단위 모듈을 통합할 수록 구현 가능한 기술은 줄어든다. (O, `X`)

하나의 기능만 구현할 수 있기 때문에 독립적 컴파일은 불가능하다. (O ,`X`)

단위 기능 명세화는 `추상화`, `구조화`, `캡슐화` 의 단계를 거친다

모듈 간 통신 방식 구현을 위한 인터페이스의 집합은 `IPC` 이다

단위 모듈 테스트 과정은 시스템 수준의 오류는 잡아낼 수 없다 (`O`, X)

`화이트박스` : 소스 코드의 논리적인 경로 테스트

`블랙박스` : 해당 기능의 작동 여부 테스트

`통합개발환경` : 개발에 필요한 다양한 툴을 하나의 인터페이스로 통합

`빌드 도구` : 소스 코드를 소프트웨어로 변환

협업 도구는 익숙치 않아도 다수를 위해 사용하는 것이 이익이다 (O, `X`)

테스트 케이스
- 식별자(Identifier) : 식별자 일련번호
- 테스트 항목(Test Item) : 테스트 대상
- 입력 명세(Input Specification) : 입력 데이터, 조건 
- 입력 명세(Input Specification) : 입력 데이터, 조건
- 출력 명세(Output Specification) : 예상 결과
- 환경 설정(Environmental Needs) : 필요 HW/SW
- 특수 절차 요구(Special Procedure Requirement) : 요구 절차
- 의존성 기술(Intel-case Depedencies) : 케이스간 의존성

테스트 단계
- 계획(제어) : 계획 수립
- 설계(분석) : 시나리오 및 케이스 작성
- 구현(실현) : 테스트 프로시저 작성, 테스트 수행
- 평가 : 평가 기록
- 완료 : 산출물 저장

---

SW패키징/릴리즈노트/DRM

소프트웨어 패키징은 설치 될 시스템 중심으로 진행된다. (O, `X`)

패키징 이후로는 지속적인 관리 및 변경이 어렵다. (O, `X`)

코드작성-구분-모듈화-`빌드`-`환경정의`-`적용테스트`-개선-배포

릴리즈 노트에 포함되는 내용 : `전체 기능, 서비스, 개선사항`

베타 테스트, 사용자의 요구로 수정된 경우엔 추가하지 않는다. (O, `X`)

저작권 : `저작물에 대해 저작자가 가지는 배타적(독점적) 권리`

용량이 큰 프로그램들은 실시간으로 DRM패키징을 진행해야한다. (O, `X`)

클리어링하우스 : `라이선스 관리, 발급, 결제`

DRM관리기술 : `암호화, 키(식별), 정책관리, 인증, 크랙방지`

---

메뉴얼 작성

설치 메뉴얼
- 목차 및 개요 : 설치 과정(순서) 요약
- 서문 : 문서 이력, 주석(주의, 참고), 구성, 설치환경
- 기본항목
    - 설치화면 : 각 과정의 이미지 첨부
    - 오류설명 : 주의사항
    - 결과하면 : 최종화면 공지
    - FAQ : 문제발생시 해결방안
    - 점검사항 : 환경, 권한점검
    - 네트워크 : 연결상태 및 보안
    - 고객지원 : 웹사이트, 연락처
    - 보증 : 준수사항 및 라이선스 정보

사용자 메뉴얼
- 목차 및 개요 : 설치 과정(순서) 요약
- 서문 : 문서 이력, 주석(주의, 참고), 구성, 설치환경
- 기본항목
    - UI화면 : 각 과정의 이미지 첨부
    - 주요기능 : 기능에 대한 사용법
    - 설정 : 설정 및 기본값
    - 장치연동 : 연동되는 장치
    - 프로파일 : 필수 구동 환경
    - 네트워크 : 연결상태 및 보안
    - 고객지원 : 웹사이트, 연락처
    - 보증 : 준수사항 및 라이선스 정보

--- 

어플리케이션 테스트 분류

기본원리와 특징
- 완벽한 테스트는 불가능하다.
- 상황에 맞게 테스트 한다.
- 파레토 법칙
- 살충제 역설
- 오류 부재의 궤변

개발자 - 검증(의도한 기능 구현)
사용자 - 확인(요구사항 포함 여부)

테스트기반
- 명세 기반 테스트 
- 구조 기반 테스트
- 경험 기반 테스트 : 명세 불충분, 시간 부족할 떄

실행 여부
화이트 박스
- 초기 수행(논리적인 경로 테스트)
- 기초 경로 테스팅 : 복잡성 테스트
- 제어 구조 테스팅 : 조건, 반복, 흐름
- 문장 검증 기준 : 모든 구문을 한 번 이상 수행했는가
- 분기 검증 기준 : 모든 조건문을 한 번 이상 수행했는가
- 조건 검증 기준 : 모든 조건문을 참, 거짓을 각각 한 번 이상 수행했는가

블랙 박스
- 개발 후반 수행(기능 테스트)
- 동치 분할 - 동등한 정상 및 비정상 인풋으로 결과 확인
- 경계값 분석 - 입력 조건의 경계값으로 테스트
- 원인-효과 그래프 : 입출력 상항을 분석하여 높은 효율로 테스트
- 오류 예측 검사 : 과거의 경험, 테스터의 감각으로 테스트(추가적)
- 비교 검사 : 동일한 테스트를 여러 버전에 진행하여 결과 테스트

목적
- 회복 : 복구가 잘 되는지.
- 안전 : 외부의 침입을 막을 수 있는지
- 강도 : 과부하에 견딜 수 있는지
- 성능 : 응답시간과 처리량의 성능 테스트
- 구조 : 코드의 복잡도를 확인
- 회귀 : 수정된 코드에 결함이 없는지
- 병행 : 기존 SW와 수정된 SW에 동일한 인풋으로 결과를 비교

---

개발 단계별 어플리케이션 테스트

통합테스트
- 요구분석 -> 아키텍처 설계 -> 모둘 설계 -> 구현 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트
- 단위테스트
    - 구조 기반 - 화이트박스(복잡도)
    - 명세 기반 - 블랙박스(기능테스트)

비점진적 방식
- 한번에 통합. 단시간 테스트 오류 파악 및 수정 어려움

점진적 방식
- 단계적 통합. 오류 수정 용이
    - 하향식(깊이 우선 통합, 너비 우선 통합), 상향식

테스트 프로세스
계획 -> 설계 -> 시나리오 -> 수행 -> 결과평가 -> 결함관리
- 시나리오
    - 테스트 케이스 : 구현된 기능의 기대 결과를 비교하는 항목들
    - 테스트 시나리오
        - 여러 테스트 케이스의 집합(절차 명세)
        - 모듈 간 연결테스트가 가능하도록 분류
        - 특정 기준으로 여러 개의 시나리오로 분류
    - 테스트 오라클 : 기대 결과와 실제 결과를 비교하는 기법
        - 특징 : 제한적, 수학적, 자동화
        - 종류 :
            - 참 오라클 - 모든 결과 비교, 미션 크리티컬
            - 샘플링 오라클 - 특정 케이스만 비교
            - 추정 오라클 - 샘플링 + 나머지 추정
            - 일관성 검사 오라클 - 어플리케이션의 변경 전과 후 결과 비교

---

테스트 자동화 / 성능 분석

테스트 자동화
- 장점 
    - 자원(인력, 시간) 감소
    - 품질 보장, 일관성(객곽적 평가)
    - 시각적 표현, UI없는 서비스도 테스트 가능
- 단점
    - 교육 및 학습을 위한 자원(시간, 비용)이 필요함
    - 상용SW인 경우 추가 비용이 필요함

유형별 테스트 자동화 도구
- 정적 분석 도구 : 실행 없이 코딩 표준 및 복잡도 체크
- 테스트 실행 도구 : 스크립트 언어를 사용하여 테스트
    - 데이터 주도 접근 방식 - 다양한 데이터를 동일한 테스트 케이스로 반복 실행
    - 키워드 주도 접근 방식 - 데이터 + 키워드(다양한 수행 동작)
- 성능 테스트 도구 : 처리량, 응답 시간, 결과 시간, 자원 사용률 측정
- 테스트 통제 도구 : 테스트 계획 및 관리, 결함 관리, 형상 관리
- 테스트 하네스 : 테스트를 위해 생성한 코드 및 데이터
    - stub : 제어 모듈이 호출하는 모듈(하위)의 기능을 수행하는 모듈
    - driver : 하위 모듈의 인터페이스 역할(호출 및 인자전달)을 수행하는 모듈
    - test case : 입력 및 기능에 대한 기대 결과를 명세한 명세서
    - test suites : 테스트 케이스의 집합(시나리오와 달리 절차, 순서가 없음)
    - test script : 자동화 테스트 절차에 대한 명세서
    - mock obejct : 조건에 맞는 상황에 특정 기능이 수행되도록한 객체

결함 관리 프로세스
- 계획 -> 기록 -> 검토 -> 수정 -> 재확인 -> 보고서 작성

결함 상태 추적
- 등록 -> 검토(해제 -> 해결, 보류 -> 등록) -> 할당 -> 수정 -> 해결

결함의 분류
- 시스템 결함 : 어플리케이션 및 DB의 작동 불능(지연)
- 기능 결함 : 프로세스와 기능의 결과가 기대결과와 불일치
- GUI 결함 : UI 비일관성, 표시 오류, 부정확한 메시지
- 문서 결함 : 문서, 메뉴얼의 불일치와 의사소통이 원할하지 않음

심각도
- HIGH : 작동불능
- MEDIUM : 흐름에 영향(부정확한 기능)
- LOW : 약간 불편(오타)

어플리케이션 성능 저하 원인 북석
- DB 연결
    - 과도한 조회, 갱신(DB Lock)
    - 불필요한 데이터 요청(DB Fetch)
    - 사용 후 종료하지 않음(Connection Leek)
    - 커넥션 풀 사이즈가 너무 작거나 큼
    - 잘못된 트랜잭션(commit)
- 내부로직
    - 인터넷 접속 불량
    - 업로드/다운로드 상태 불량
    - 예외 처리 불량
- 외부/환경설정
    - 외부 작업에 대한 장시간 지연
    - 메모리 크기 작게 설정
    - 네트워크 장비 오류 및 지연

- Clean Code : 가독성, 의존성 배제, 단순성, 중복 최소화
- Bad Code : 복잡함, 중복됨, 로직 서로 얽혀있음

---

인터페이스 기능 구현

모듈 세부 설계서 (컴포넌트 명세서, 인터페이스 명세서)
- 설계와 표준에 맞게
- 정형화(일정한 형식)
- 쉽고 직관적으로
- (다이어그램 활용)

통신을 이용한 구현
- XML(eXtensible Markup Language)
    - 마크업(태그)과 콘텐트(내용)으로 구성
    - 새로운 태그 생성가능, 다목적 마크업 언어

- JSON(JavaScript Object Notation)
    - 독립적, 개방적 표준(인기만점), XML을 대체
    - 속성과 값으로 이뤄진 데이터 객체 전달
    - 보편적으로 AJAX(웹2.0 기술 통칭) 기술에서 사용

엔티티를 이용한 구현
- 송신 시스팀(데이터 쓰기) -> 송신측 테이블 -> Data Transfer -> 수신측 테이블 -> 수신 시스템(데이터 사용)

예외(오류) 처리 방식
- 통신으로 구현된 인터페이스에서 예외처리
    - 송신 측
        - AJAX 반환값이 fail 이면 처리 
        - 메시지에 따라 처리절차 구분
        - 비동기, 콜백 처리
    - 수신 측
        - try ~ catch 구문 사용

- 엔티티로 구현된 인터페이스에서 예외처리
    - 송신 측
        - 입력 데이터 전송시 발생
        - 실패 상황, 원인기록
        - 예외 코드 입력
    - 수신 측
        - 데이터 처리중 발생
        - 예외 코드 입력
        - 사유, 상황 기록

보안 취약점 구분
- 통신 : 스니핑(sniffing, 수동적 해킹)으로 데이터 탈취
- 어플리케이션
    - OWASP(Open Web Application Security Project) 참고
    - 입력데이터 검증, API이용, 에러처리, 품질, 캡슐화 등
- DB
    - 알고리즘 적용 : 대칭(DEA), 비대칭(RSA), 해시(SHA)
    - 기법 적용 : API(어플기준), plug-in(DB기준)

---

인터페이스 구현 검증

기대 결과 = 실제 결과
구현 기술에 따라 검증도구 요건(필요한 조건) 달라짐

- 검증 도구(자동화)
    - xUnit : java(Junit), C++(Cppunit) 등 다양한 언어를 지원하는 단위 테스트 프레임워크
    - STAF : 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
    - FitNesse : 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크
    - NTAF : Naver 테스트 자동화 프레임워크이며, STAF, Fitnesse를 통합
    - Selenium : 다양한 브라우저(웹) 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크
    - watir : Ruby(언어) 기반 웹 애플리케이션 테스트 프레임워크

- 모니터링 도구
    - ARM(Application Performance Management)

- 사용자 화면 출력
    - 입력 데이터를 즉시 사용하는 경우

- 오류 로그 생성
    - 관리자가 자세한 내역을 확인 가능

- 테이블에 오류 기록
    - 엔티티&트랜잭션

---

## 실기

#### 1회

1. 살충제 패러독스 개념 설명
    - 동일한 테스트케이스로 반복실행하면 더 이상 새로운 결함을 발견할 수 없으므로 주기적으로 테스트 케이스를 점검하고 개선해야한다.

2. 데이터 마이닝 개념 설명
    - 많은 데이터 가운데 숨겨져 있는 유용한 상관관계를 발견하여, 미래에 실행 가능한 정보를 추출해 내고 의사 결정에 이용하는 과정을 말한다.

3. 프로토콜 3요소
    - 구문, 타이밍, 의미

4. 웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 다목적 마크업언어
    - XML

5. 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷이다. AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷이다. 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용되고 있다.
    - JSON

6. HRN 우선순위 계산식
    - (대기 시간 + 서비스 시간) / 서비스 시간

7. 트랜젝션 특성 ACID 중 일관성, 지속성 외 2개의 특성
    - 원자성, 독립성

8. 공격자가 패킷의 출발지 주소나 포트를 임의로 변경하여 출발지와 목적지 주소를 동일하게 함으로써, 공격 대상 컴퓨터의 실행 속도를 느리게하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격기법. 수신되는 패킷 중 출발지 주소와 목적지 주소가 동일한 패킷들을 차단함으로써 이 공격을 피할 수 있다.
    - LAND 공격

9. 128비트 암호화 해시 함수이다. RFC 132로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. 1991년에 로널드라이베스트가 예전에 쓰이던 MD5를 대체하기 위해 고안했다.
    - MD5

10. 모듈 설계시 (1)는 낮추고, (2)는 높여야한다.
    - 1 : 결합도, 2 : 응집도

11. 릴리즈노트 작성 항목 중 문서 이름, 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등을 기술하는 작성항목이 무엇인지 쓰시오.
    - 헤더

12. Loc 기법 개발 기간 계산식과 답 입력 (총 라인 30,000, 개발자 5명, 인당 월평균 300라인)
    - (30000 / 300) / 5

13. OSI 7 참조 모델 중 두 장비 간의 전송을 위한 연결이나 전달 등의 인터페이스의 기계적, 전기적, 절차적 특성을 정의하며 비트를 물리적인 매체를 통해 전송하는 계층을 쓰시오.
    - 물리 계층

14. 애플리케이션의 성능을 측정하기 위한 지표
    - 처리량, 응답 시간, 경과 시간

15. 비정규화의 개념 : 반정규화에 대한 문제
    - 시스템의 성능 향상, 개발 과정의 편의성, 운영의 단순화를 목적으로 수행되는 의도적인 정규화 원칙 위배행위를 말한다.


#### 2회

1. (   )(은)는 프로젝트 진행 도중에 일부 결과물인 시제품을 고객에세 지속적이며 반복적으로 제공한다. 고객의 요구사항이 정확하게 반영되고 있는지 수시로 점검하게 된다.
    - 애자일 방법론

2. 데이터베이스 설계의 순서를 쓰시오.
    - 요구사항 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현

3. HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 형태의 프로토콜로써 Envelope, Header, Body의 주요 3요소로 구성된 간접 연계 방식의 웹서비스의 기본적인 메시지 전송 수단을 의미하는 용어를 쓰시오.
    - SOAP

4. 소프트웨어( )는 변경제어, 개발 전반 산출몰에 대하여 관리한다. 관리하는 도구로 Git, SVN 등이 있다.
    - 형상관리

5. 자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술이다. 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법이다.
    - AJAX

6. UI는 사용자와 컴퓨터 상호 간의 소통을 원활히 할 수 있도록 도와주는 연계 작업을 뜻한다. 다음의 UI 설계 원칙 4가지이다. 빈칸 괄호 ( )에 알맞은 용어를 쓰시오.
    - 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야한다.
    - (유효성) : 사용자의 목적을 정확하게 달성하여야 한다.
    - 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다.
    - 유연성 : 사용자의 요구사항을 최대한 수용하며, 오류를 최소화하여야 한다.

7. 애플리케이션 자동화 테스트 도구 유형 중 ( )은(는) 애플리케이션을 실행하지 않고, 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위하여 사용하는 분석이다.
    - 정적 분석 도구

8. SELECT 학번, 이름 FROM 학생 WHERE 학년 IN (3, 4);

9. CREATE INDEX idx_name ON student(name);
    - CREATE INDEX {index name} ON {table name}(column name1, column name2, ...); 

10. 소프트웨어 보안의 취약점 중 하나인 SQL Injection에 대해 간략히 설명하시오.
    - 웹 응용 프로그램에 강제로 SQL 구문을 삽입하여 내부 데이터베이스 서버의 데이터를 유출 및 변조하고 관리자 인증을 우회하는 공격기법이다.

11. { '한국', '중국', '베트남', '홍콩', '태국' }

12. ROLLBACK 개념 설명 
    - 트랜잭션의 실패로 작업을 취소하고, 이전 상태로 되돌리는 데이터 제어어 이다.

13. 네트워크 계층인 IP계층에서 IP 패킷 단위로 `암호화`, `인증`, `키 관리`를 통해 보안성을 제공해주는 표준화 된 기술을 무엇이라 하는지 쓰시오.
    - IPSec

14. 리눅스 커널을 기반으로 동작하며 자바와 코틀린 언어로 개발된 핸드폰이나 소형기기에 사용되는 오픈소스 플랫폼인 모바일 운영체제가 무엇인지 쓰시오.
    - 안드로이드

15. 리눅스에서 사용자에게는 `읽기/쓰기/실행`, 그룹에게는 `읽기/실행`, 기타에게는 `실행` 권한을 a.txt파일에 부여하는 명령어를 쓰시오.
    - chmod 751 a.txt
        - user/group/other ) R = 4, W = 2, X = 1

16. "비상사태 또는 업무 중단 시점부터 업무가 복구 되어 다시 정상가동 될 때 까지의 시간" 을 의미하는 용어를 쓰시오.
    - 목표 복구 시간(RTO)

17. 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 (ont-to-many) 의존성을 가지는 디자인 패턴. 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야한다.
    - Observer

18. 전세계 오픈 된 정보를 하나로 묶는 방식으로, Linked data와 Open data의 합성어
    - Linked Open Data

#### 3회

1. EAI 구축유형 중 Message Bus와 Hybrid를 제외한 빈칸에 알맞은 유형을 작성하시오.
    - ( Point to Point || Peer to Peer ) : 두 대의 컴퓨터가 직렬 인터페이스를 이용하여 통신을 할 때 사용하는 프로토콜
        - 가장 기본적인 애플리케이션 통합 방식
        - 변경 및 재사용이 어렵다.
    - ( Hub & Spoke ) : 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
        - 확장 및 유지 보수가 용이
        - 허브 장애 시 시스템 전체에 영향을 미친다.
    - Message Bus : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
        - 확장성, 대용량 처리 우수 (ESB 방식)
    - Hybrid : Hub & Spoke와 Message Bus의 혼합
        - 그룹 내에서는 Hub & Spoke 방식으로 연결하고, 그룹 간에는 Message Bus 방식으로 연결
        - 데이터 병목 현상을 최소화

2. 대표적인 내부 라우팅 프로토콜로, 링크 상태 라우팅 프로토콜로도 불리느 라우팅 프로토콜이다. RIP의 단점을 해결한 프로토콜이며 대규모 네트워크에 적합하다.
    - OSPF

3. 심리학 톰 마릴은 컴퓨터사 메시지를 전달하고 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 가리켜 '기술적 은어'라는 뜻으로 ( )(이)라 불렀다.
    - 프로토콜

4. 헝가리안 표기법 개념 설명
    - 컴퓨터 프로그래밍에서 변수나 함수의 이름 앞에 데이터 타입을 명시하는 코딩 규칙이다.

- 카멜 케이싱 : 소문자로 시작, 단어 사이의 단락을 대문자로 표기
- 파스칼 케이싱 : 대문자로 시작, 단어 사이의 단락을 대문자로 표기
- 스네이크 케이싱 : 소문자로 시작, 단어 사이의 단락을 _(밑줄)로 표기
- 헝가리안 표기법 : 이름 앞에 데이터 타입을 명시, 데이터 타입은 정해진 약어로 표시
- GNU Naming Convention : 모든 문자 소문자, 단어 사이의 단락을 _(밑줄)로 표기
- 상수 표기법 : 모든 문자 대문자, 단어 사이의 단락을 _(밑줄)로 표기

5. 데이터베이스의 스키마에 대해 간략히 서술하시오.
    - 데이터베이스의 구조와 제약조건에 대한 명세를 기술한 것 이다.

6. UI 설계 원칙 중 직관성 개념 설명
    - 누구나 쉽게 이해하고 사용할 수 있어야 한다.

7. C++ 생성자 개념 설명
    - 객체 생성시 초기화 작업을 위한 함수로써, 객체를 생성할 때 자동으로 호출되고 제일 먼저 실행된다.
    - new 연산자를 통해서 객체를 생성할 때 반드시 호출되고 제일 먼저 실행되는 일종의 메서드

8. 형상 통제 개념 설명
    - 산출물의 변경사항을 버전별로 관리하여 목표 시스템의 품질 향상을 지원하는 활동
    - 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업

9. TCP/IP 기반의 인터넷 통신 서비스에서 인터넷 프로토콜(IP)과 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경 등을 위한 제어 메시지를 취급하는 무연결 전송용의 프로토콜로 OSI 기본 참조 모델의 네트워크층에 해당한다.
    - ICMP

10. 리팩토링을 하는 목적
    - 코드의 외부 행위는 바꾸지 않고 내부 구조를 개선시켜 소프트웨어를 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것 이다.

11. 릴레이션
    - Select : σ : 조건에 맞는 튜플을 구하는 수평적 연산
    - Project : π : 속성 리스트로 주어진 속성만 구하는 수직적 연산
    - Join : ⋈ : 공통 속성을 기준으로 두 릴레이션을 합하여 새로운 릴레이션을 만드는 연산
    - Division : ÷ : 두 릴레이션 A, B에 대해 B 릴레이션의 모든 조건을 만족하는 튜플들을 릴레이션 A에서 분리해 내어 프로젝션하는 연산
    - 합집합 : ⊔ : 두 릴레이션의 튜플의 합집합을 구하는 연산
    - 교집합 : ⊓ : 두 릴레이션의 튜플의 교집합을 구하는 연산
    - 차집합 : - : 두 릴레이션의 튜플의 차집합을 구하는 연산
    - 교차곱 : X : 두 릴레이션의 튜플들의 교차곱(순서쌍)을 구하는 연산

12. 내부 구조를 보지않고 주로 구현된 기능을 테스트하는 테스트 기법으로, 동치 분할 테스트, 경계값 분석 세트스 등을 이용하는 테스트 기법을 쓰시오.
    - 블랙박스 테스트 

#### 4회

1. goF의 디자인 패턴은 생성, 구조, ( )가 있다. 생성 패턴은 객체의 생성에 관련된 패턴이고 구조 패턴은 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이며 ( ) 패턴은 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이다.
    - 행위

2. 탭이 달린 폴더안에 요소들을 집어넣어 표현하는 다이어그램으로 컴포넌트 구조 사이의 관계를 표현하며 요소들을 그룹으로 조직하기 위한 매커니즘의 UML 다이어그램이 무엇인지 쓰시오.
    - 패키지 다이어그램

3. 테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말한다. 테스트 오라클의 유형 중 전수 테스트가 불가한 경우 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클로 경계값, 구반별 예상값 결과 작성시 사용하는 오라클을 무엇이라 하는지 쓰시오.
    - 샘플링 오라클

4. 명세기반 테스트의 기법 중 프로그램의 입력 조건에 중점을 두고, 어느 하나의 입력 조건에 대하여 타당한 값과 그렇지 못한 값을 설정하여 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 테스트 기법은?
    - 동치분할 테스트

5. 스니핑에 대하여 간략히 설명하시오.
    - 네트워크상에 통과하는 패킷들의 내용을 엿보는 행위이다.

6. 정보보안의 목표 중 가용성에 대하여 간략히 설명하시오.
    - 합법적 사용자가 합법적 정보를 요구할 때 적시에 제공되어야 하는 원칙을 말한다.
    - C : 기밀성으로 인가받지 않는 대상에게는 정보를 공개하지 않는 것이다.
    - I : 무결성으로 인가받지 않는 대상이 정보를 변경, 생성, 삭제하지 않도록 하는 것이다.
    - A : 가용성으로 합법적 사용자가 합법적 정보를 요구할 때 적시에 제공되어야 하는 것이다.