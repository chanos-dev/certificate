### 간단 정리
- [정보처리기사 필기 강의](https://www.youtube.com/channel/UCczcbg-Pv6pzn9Zp9lQ3WZA)
- [정보처리기사 소프트웨어 설계 1과목](#1과목)
- [정보처리기사 소프트웨어 개발 2과목](#2과목)
---
### 1과목

소프트웨어 생명 주기

- 소프트웨어 개발 과정을 단계별로 나눈 것

폭포수 모델

- 각 단계를 한 번씩만 거침 (되돌릴 수 없음)
- 단계별 철저한 검증 필요
- 메뉴얼 작성 필요

프로토타입 모델 (원형 모델)

- 기능적 인터페이스 중심으로 견본 개발 후 최종 개발 추 후 발견 될 오류 방지

나선형 모델 

- 계획 - 분석(검증) - 개발 - 평가(오류 방지)의 단계를 반복 폭포수와 프로토타입의 장점을 흡수하여 점진적 개발
- 대규모 소프트웨어 개발에 용이

애자일 모델

- 요구사항 반영 및 고객과의 의사소통 빈도를 높이는 것이 목표.
- 여러 개발 방법을 아우르는 모델

---

스크럼 기법 

- 팀 중심, 제품 책임자, 스크럼 마스터, 개발팀으로 구성

제품 책임자(PO)

- 의사 결정자
- 백로그의 우선순위 지정

스크럼 마스터

- 일일 회의 주관, 개발 가이드

개발팀 : 개발자 뿐 아니라 디자이너, 테스터 등 모든 인원

프로세스 -

- 백로그 : 요구사항을 우선순위에 따라 모아놓은 목록
- 계획 회의 : 스프린트 일정 수립, 개발자 별로 스프린트 백로그 작성
- 스프린트 진행 : 할 일, 진행 중, 완료
- 일일 회의 : 스크럼 마스터 주도, 소멸차트 활용
- 검토 회의 : 주별, PO 주도, 백로그 업데이트
- 회고 : 지난 일정 되돌아보기, 개선점 찾기

---

XP 기법

- 짧고 반복적인 개발 주기, 고객의 적극적 참여를 통한 가시성 향상
- 소규모 인원의 개발 프로젝트에 효과적

핵심가치 (피-존-용-단-소)

- 피드백, 존중, 용기, 단순화, 소통

개발 프로세스 -

- 사용자 스토리 : 고객의 요구사항
- 릴리즈 계획 수립 : 부분과 전체의 개발 일정 수립
- 스파이크 : 기술 및 기능확인을 위해 간단히 만드는 프로그램
- 이터레이션 : 릴리즈를 좀 더 세분화 한 단위
- 승인 검사 : 부분 소프트웨어가 릴르즈 되면 고객이 직접 평가
- 소규모 릴리즈 : 릴리즈 별로 고객의 피드백 확인 가능

---

 시스템 파악 : 시스템 개발 범위를 명확하게 설정 (구기인아소하네)

- 시스템 구성 : 기간(주요) 업무와 지원 업무의 주요 기능 파악
- 시스템 기능 : 주요 기능별 세부 기능들을 계층형으로 표시
- 시스템 인터페이스 : 주고받는 데이터의 형식, 프로토콜 파악
- 아키텍처 구성 : 주요 업무 시스템의 구성과 동작원리를 표현
- 소프트웨어 구성 : 종류 및 라이선스의 적용방식과 비용
- 하드웨어 구성 : 서버의 주요 사양과 수량, 이중화 적용 여부
- 네트워크 구성 : 구성도 작성. 물리적 위치, 보안 취약점, 유지보수

---

개발 기술 환경 파악

- 운영체제 : 시스템 자원 관리, 하드웨어 제어를 위한 인터페이스
    - 고려사항 : 주변기기 지원여부
- DBMS : 데이터베이스 관리를 위한 시스템, 종속성과 중복성 해결,  DB에 대한 모든 권한과 책임이 있음
    - 고려사항 : 상호 호환성, 데이터 이중화
- WAS : 동적 콘텐츠 처리를 위한 미들웨어, DB서버와 연동
    - 미들웨어 : 서버와 클라이언트 중간에 위치, 클라이언트 대신 복잡한 처리를 하기 위함
    - 고려사항 : 다양한 옵션
- 공통 고려사항 : 가용성, 성능, 비용, 기슬지원
- 오픈소스 : 라이선스 종류, 기술 지속 가능성, 사용자 수

---

요구사항 정의/분석/확인

요구사항 : 서비스에 대한 설명 및 제약조건

- 기능 : 기능 자체
- 비기능 : 기능의 품질, 제약사항
- 사용자 : 쉬운 표현 사용
- 시스템 : 개발자 입장, 전문용어

요구사항 개발 프로세스 : 도출(의사소통) → 분석 → 명세(문서화) → 확인

- 분석 : 타당성 조사, 특정 기준으로 분류
    - 개념 모델링 : 단순화, 개념적 표현, 객체 간 관계와 종속성 분석
    - 협상 : (기능과 비 기능, 필요 자원, 서로)의 요구사항이 충돌하는 경우
    - 정형 분석 : 마지막 단계, 구문과 의미를 갖는 언어 사용, 수학적 기호로 표현
- 확인 : 검증
    - 검토 : 일반적, 고객 대표 포함
    - 모델 검증 : 정적(논리적) 검증, 실행안함
    - 프로토 타이핑 : 지속적인 프로토타입 작성, 사전 피드백
        - 단점 : 프로토 타입에만 집중, 비용부담, 과대평가
    - 인수 테스트 : 사용자 입장에서 요구사항 체크(계획 필요)

---

UML(Unified Modeling Language)

1. 물리적인 자원의 위치를 표시하는 것으로 구현 단계에서 사용되는 것은? → 배치 다이어그램
2. 사물의 종류 중 (구조, 행동, 주해)를 제외한 나머지 하나는? → 그룹
3. (시퀀스, 상태, 배치, 활동)중, 동적인 행위를 표현하기 위한 것이 아닌 것은? → 배치 다이어그램
4. UML 다이어그램 중, 구현 단계에서 사용하기 적절한 것은? → 컴포넌트, 배치
5. 의존, 실체화 관계에서 처럼, 일시적인 관계를 표현할 때 사용되는 선은? → 점선 화살표
6. 다중도 표현에서 ('다수', '또는')에 해당하는 기호는? *와 ..
7. 자동차와 열쇠의 관계를 표현하기 가장 적절한 관계는? → 포함관계

---

사용자 인터페이스

사용자 인터페이스 3가지 분야 : 제어, 구성, 기능

사용자 인터페이스의 특징
- 만족도에 큰 영향을 끼치기 때문에, 가장 많이 변경된다.
- 편리성과, 가독성, 이해도를 높인다.
- 최소한의 노력으로 결과를 얻을 수 있도록 한다.
- 소프트웨어 아키텍처를 숙지해야 한다.

사용자 인터페이스의 구분 : CLI(텍스트), GUI(마우스), NUI(말, 행동)

사용자 인터페이스의 기본 원칙 : 직관, 유효, 학습, 유연

사용자 인터페이스의 설계 지침
- 사용자 중심, 일관성, 단순성, 결과 예측 가능, 표준화, 접근성, 명확성, 가시성, 오류 발생 해결

---

UI 설계 도구

표준 및 지침에 따라 UI를 제작하기 위해선 설계도가 필요

설계도는 결과물에 대해 미리보기 기능을 함

와이어프레임(wireframe) : 뼈대(레이아웃) 배치, 화면 단위

목업(mockup) : 실제화면과 유사. 기능 구현 아님.

스토리보드(storyboard) : 와이어프레임 + 콘텐츠 설명, 이동경로, 작업지침서 활용 (설명은 세부적 작성 필요)

프로토타입(prototype) : 인터렉션 적용 (동적인 형태)

유스케이스(use case) : 사용자 요구사항(기능적)을 다이어그램 형식으로 문서화, 각각의 유스케이스에 대한 명세서 작성

---

UI 요구사항 확인

개인별 인터뷰를 통해 가능한 많은 사람들과 인터뷰를 진행한다.

인터뷰를 통해 사업적, 기술적인 요구사항을 명확히 한다.

리서치를 진행하기 전 인터뷰를 해야 보다 효율적이다.

활동사항을 정의할 때는 서로 협의를 통해 진행한다.

요구사항의 작성은 사용자 중심으로 하여 개발에 편리하도록 한다.

UI 요구사항 중 가장 먼저 데이터에 대한 정리를 진행한다.
- 데이터 : 가장먼저 확인, 특성 기반 정리
- 기능 : 무엇을 실행하는지? 동사형으로 정리
- 품질 : 품질, 서비스, 감성적인 부분
- 제약 : 비용과 데드라인, 규제 등

정황 시나리오는 완성 된 서비스를 상상하며 최대한 자세히 작성한다.

요구사항은 정황 시나리오를 토대로 작성한다.

---

품질 요구사항

SW품질에 대한 국제 표준 지침 = ISO/IEC 9126

기능 : 적절한 기능이 정확하게 + 호환, 보안
- 적절성, 정확, 상호운용, 보안, 호환

신뢰 : 결함에도 문제 없이.
- 성숙, 회복, 고장허용

사용 : 얼마나 쉽고 편한지
- 이해, 학습, 운용, 친밀

효율 : 한정된 시간, 자원으로 많은 일 처리
- 시간, 자원

유지보수 : 개선 및 확장
- 분석, 변경, 시험, 안정

이식 : 다른 환경에서 적응
- 적용, 설치, 대체, 공존

---

UI 프로토타입 제작 및 검토

UI 프로토타입 : 동적인 형태(실제 동작하는 것처럼)의 테스트 모델, 필수 기능을 포함, 간단하게, 실 사용자 테스트로 기능 검증

장단점 : 이해와 오류발견이 쉽다 / 자원소모 생략 가능성

종류
- 페이퍼 : (손으로)-저렴, 즉시, 간단
- 디지털 : (SW로)-결과와 비슷, 테스트 및 수정, 어려움

고려사항
- 계획 : 목적 - 환경 - 핵심UI - 인원 - 검증 - 해결 - 가이드
- 작성 : 범위확인 - 목표확인 - 자원확인

제작단계 : 요구사항분석 - 요구사항작성(프로토타입) - 사용자 테스트 및 수정 - 사용자 피드백 및 승인
- 사용자 테스트 / 피드백 부분은 반복될 수 있다.

---

UI 설계서 작성

표지 : 프로젝트(시스템) 명

개정이력 : 초안작성 이후 변경할 때마다 버전이 증가

요구사항 정의서 : 요구사항 별 적용여부 기록

시스템 구조 : 전체 시스템(사용자, 관리자 등)의 구조 설계

사이트 맵 : 전체 콘텐츠 메뉴별 구성 + 표 형태로 작성

프로세스 정의서 : 사용자 입장에서 작업이 진행되는 순서도

화면설계 : 각화면별로 표지 + 스토리보드

---

UI 유용성평가, 상세설계, 감성공학

유용성평가
- 뜻 : 사용자 입장에서 얼마나 유용한지
- 실행(기능) : 불필요, 중복, 불편, 어려운
- 결과(평가) : 즉각적이지 않은 피드백, 결과 이해, 파악이 어려움

상세설계
- 시나리오 : 순서도나 계층구조로 작성
- 일반규칙 : 기능, 구조, 인터렉션, 예외처리 (이후 세부기능 정의)
- 기대효과 : 긍정적인 문장과 단어 (완전, 일관, 이해 등...)

감성공학
- HCI(Human Computer Interface) : 편리하고 안전한 시스템 개발(최적의 UX가 목표)
- UX(User eXperience) : 시스템 이용경험, 주관적임(객관적인 UI편리성과 반대)
- 감성공학 : 감성적, 인간친화적 개발

---

소프트웨어 아키텍처

SW 아키텍처
- 뜻 : 기본 구조, 개발 기반
- 역할 : 품질유지, 원칙, 지침
- 모듈 : 부품

기본원리
- 모듈화 : 유지관리에 좋음. (많으면 통합비용 ↑, 적으면 개발비용 ↑)
- 추상화 : 포괄적 개념, 구체화 하기 위해 필요. 가성비. 구조파악 용이.
- 단계적 분해 : 하향식. 추상화의 반복으로 더 많은 단계의 분해 가능.
- 정보은닉 : 접근금지. 별도의 인터페이스 사용. 유지보수에 용이. 

품질속성
- 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성
- 비지니스 측면 : 시장 적시성, 비용과 혜택, 시스템 수명
- 아키텍처 측면 : 무결성, 정확성, 완결성, 구축가능성

설계과정 : 목표 - 시스템타입 - 아키텍처패턴 - 시스템구체화 - 검토

---

아키텍처 패턴

레이어 : 상/하위 계층끼리 상호작용

P2P : 서버와 클라이언트 역할 변경 가능

모델-컨트롤러-뷰 : 대화형 어플리케이션에 적합

서버-클라이언트 : 1:다 / 항시대기 / 독립적 기능

파이프-필터 : 재사용, 확장, 변환, 동기화, 버퍼링

블랙보드 : 공유 데이터 검색, 인식, 식별 

---

모듈

모듈
- 뜻 : 모듈화 된 기능. 서브루틴, 서브시스템 등오로도 불림 / 재사용 가능 ▶
- 독립성 판당 : 약한 결합도와 강한 응집도. 품질과 련관.

결합도
- 뜻 : 모듈간 상호 의존(영향을 미치는) 정도
- 종류
    - 자료 : 데이터
    - 스탬프 : 자료구조
    - 제어 : 제어요소
    - 외부 : 외부참조
    - 공유 : 공통 데이터
    - 내용 : 내부 직접 참조

응집도
- 뜻 : 정보은닉 개념 확장, 내부 요소들끼리의 관련 종ㄷㅎ
- 종류
    - 기능 : 단일 연결
    - 순차 : 이전 출력 - 다음 출력
    - 통신 : 동일 입출력 다른 기능
    - 절차 : 다수의 기능을 순차적으로
    - 논리 : 유사한 기능 모음

팬 - 인 : 해당 모듈을 제어하는. 들어오는 화살표
팬 - 아웃 : 해당 모듈을 제어하는. 나가는 화살표

공통모듈
- 명세기법
    - 정확 : 필요성
    - 명확 : 비중의적
    - 완전 : 필요한 모든 것
    - 일관 : 중복 방지
    - 추적 : 출처/관계 파악

---

코드 / 디자인 패턴

코드 
- 순차 : 1, 2, 3, 4, 5, ...
- 블록 : A학과 : 1001 ~ 1010
- 10진 : 1317
- 그룹분류 : 1 - 04 - 002
- 연상 : LG-OLED50
- 표의숫자 : R 300-400-600

디자인 패턴
- 생성 패턴 : 캡슐화, 유연성
    - Abstract Factory : 객체 생성코드가 상위 클래스에 존재, 하위(구체화) 클래스가 받아 씀
    - Factory Method : 객체 생성코드를 하위 클래스에서 구체화. 상위 클래스는 인터페이스만 제공
    - Builder : 분리 된 인스턴스를 조합하여 객체 생성
    - Prototype : 원본 복제, 비용 저렴
    - Singleton : 클래스 내 인스턴스 하나뿐임을 보장. 동시 참조 불가능

- 구조 패턴 : 복잡한 구조의 시스템 개발에 필요
    - Adapter : 일치하지 않는 인터페이스 변환
    - Bridge : 추상층(기능)과 구현층(구체화)을 분리하여 독립적 확장
    - Composite : 트리구조 구성. 단일과 복합 개체 구분없이 다룸
    - Decorator : 기능 추가위해 다른 객체를 덧붙임
    - Facade : 서브 클래스들의 통합 인터페이스를 제공(wrapper객체)하는 상위 클래스 구성
    - Flyweight : 다수의 유사 객체 생성이 필요할 때 최대한 공유해서 사용 (메모리 절약)
    - Proxy : 접근이 어려운 객체에 접근할 수 있도록 인터페이스 역할 수행
 
- 행위 패턴 : 상호작용, 책임 분배
    - Chain of Responsibility : 둘 이상의 객체가 연결(chain)되어 책임이 차례로 넘어감
    - Command : 명령어 캡슐화(추상과 구체). 로그에 기록
    - Interpreter : 문법 표현 정의. 맞춤법 검사
    - Iterator : 접근이 잦은 객체는 동일한 인터페이스 사용하도록, 순차접근
    - Mediator : 복잡한 상호작용 캡슐화, 결합도 ↓
    - Memento : 특정 시점의 상태 객체화. 되돌리기
    - Observer : 이벤트 발행과 구독. 상태 변화 전달
    - State : 상태에 따라 동작을 다르게
    - Strategy : 동일 계열 알고리즘 상호교환. 독립적 사용
    - Template Method : 상위에서 인터페이스 정의. 하위에서 구체화(유지보수)
    - Visitor : 처리 기능을 별도의 클래스로 구성

---

시스템 인터페이스 요구사항 분석/검증

요구사항 명세서 구성
- 이름, 시스템, 범위(내용), 방식, 송신 데이터, 인터페이스 주기, 고려사항


요구사항 분석 절차
- 요구사항 선별 : 별도의 인터페이스 요구사항 목록 제작
- 자료 준비 : 시스템 인터페이스 요구사항과 관련된 자료 준비
- 요구사항 분류 : 기능적 / 비기능적 요구사항으로 분류
- 분석 및 수정 : 내용을 추가 및 수정 / 세분화 / 우선순위 부여

요구사항 검증
- 요구사항 검토 계획 : 기준과 방법, 참여자, 체크리스트, 관련자료, 일정 등
- 검증 방법 : 동료검토, 워크스루(사전검토 후 회의), 인스펙션(검토 전문가), 프로토타입 제작 / 관련 툴 사용
- 검증항목 : 완전성(누락여부), 일관성(충돌여부), 명확성(이해여부), 기능성, 검증가능성, 추적가능성, 변경용이성

---

인터페이스 시스템 식별, 송/수신 데이터 식별

인터페이스 시스템 식별
- 개발 시스템 식별 : 개발하고자 하는 시스템 정보
- 내/외부 시스템 식별 : 개발 시스템과 연계할 내/외부 시스템 정보
- 내/외부 시스템 환경 및 관리 주체 식별 : 운용환경(IP, URL, PORT, ...)과 담당자 정보
- 내/외부 시스템 네트워크 연결 정보 식별 : 인증 및 DB 정보
- 인터페이스 식별 : 시스템과 연계할 시스템 사이의 인터페이스 정보
- 인터페이스 시스템 식별 : 송신, 수신 시스템 구분(대외, 내외 구분)

식별 대상 데이터
- 인터페이스 : 시스템 연계에 필요한 표준 데이터
    - 시스템 공통부 : 연동에 필요함. 인터페이스, 시스템, 코드, 장애 정보 등
    - 거래 공통부 : 송/수신 데이터 처리, 직원, 기기, 매체 정보 등
- 송/수신 데이터 항목
    - 업무 수행에 사용되는 데이터
    - 인터페이스 별로 다름
- 공통코드
    - 공통적으로 사용하는 코드
    - 상태 코드, 오류 코드, 코드 설명 등


송/수신 데이터 식별
- 인터페이스 표준 항목 : 교환범위확인, 인터페이스 표준항목에 대한 송/수신 데이터 식별
- 코드성 데이터 항목 식별
    - 양쪽코드가 동일한 경우 : 공통 코드
    - 양쪽 코드가 다른 경우 : 양쪽 코드 정보 필요
    
---

인터페이스 방법 명세화/설계서 작성

시스템 연계 기술
- DB Link : 기본 제공. DB Link 객체 이용
- API : DB를 읽어오도록 만들어 둔 인터페이스 프로그램
- 연계 솔루션
    - EAI서버와 각 시스템에 설치 된 클라이언트를 통해 데이터 통신
    - 모니터링 및 통제 기능
- Socket : 포트할당, 클라이언트와 연결
- Web Service : SOAP, WSDL, UDDI

통신 유형
- 단방향 : 요청, 응답없음
- 동기 : 요청 및 대기, 응답
- 비동기 : 요청 및 미대기, 응답

처리 유형
- 실시간 방식 : 즉시처리, 예매, 카톡
- 지연처리 방식 : 처리시간 여유, 즉시 처리 시 비용문제, 본인인증 문자
- 배치 방식 : 일괄처리, 모아뒀다가 대량으로 한번에, 세금계산

---

미들웨어 종류

- DataBase(DB)
- Message Oriented Middleware(MOM)
- Object Request Broker(ORB)
- Remote Procedure Call(RPC)
- Web Application Server(WAS)
- Transaction Processing Monitor(TPM)

---

### 2과목

자료구조

선형 - `List`, `Queue`, `Stack`

비선형 - `Tree`, `Graph`

효율적인 프로그램을 작성할 때 가장 우선적인 고려사항은 저장공간의 `효울성`과 실행시간의 `신속성`이다.

자료구조에 따라 프로그램의 `실행시간`이 달라진다.

자료구조는 `자료`의 표현과 그것과 관련된 `연산`이다.

`선형 자료구조`는 순서에 따라 데이터에 접근하고 있는 형태이다.

`배열`은 `동일한 자료형`의 데이터들이 나열되어 있는 구조이다.

배열은 데이터 접근과 처리는 `첨자와 변수`를 이용한다.

배열은 `삽입/삭제` 작업보다 `반복적 데이터 처리`에 적합하다.

배열은 정적인 자료구조로서, `메로리의 낭비`가 발생한다.

[접근요소, 기억공간, 삽입/삭제]
연속 리스트 - 배열(첨자), 효울, 비효율
연결 리스트 - 노드(포인트), 비효율, 효율

`스택`은 자료의 삽입, 삭제가 `한쪽 방향`으로만 이루어진다.

스택은 `가장 나중`에 삽입된 자료가 `가장 먼저` 삭제되는 `후입선출`방식이다.

공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 `오버플로우`가 발생한다.

공간이 비워져 있는 상태에서 데이터가 삭제되면 `언더플로우`가 발생한다.

`큐`는 자료의 삽입, 삭제가 `서로 다른 방향`에서 이루어진다.

`가장 먼저` 삽입된 자료가 `가장 먼저` 삭제되는 `선입선출`방식이다.

Front 포인터는 `가장 먼저` 삽입 된 데이터의 위치를 기억한다.

Rear 포인터는 `가장 마지막에` 삽입 된 데이터의 위치를 기억한다.

`트리`의 맨 위에 있는 노드는 `루트노드`, 맨 아래에 있는 노드는 `터미널 노드`다.

특정 노드의 이전 레벨은 `부모노드`, 다음 레벨은 `자식노드`이다.

동일한 부모노드를 가지고 있는 노드들은 `형제노드`이다.

트리는 `순환을` 하지 않는 그래프의 형태이다.

---

데이터베이스/DBMS/SQL

`논리` 데이터저장소는 데이터 간의 연관성, 제약조건 등을 조직화한 것이다.

`물리` 데이터저장소는 하드웨어적 저장장치에 데이터를 저장한 것이다.

DBMS의 필수 기능 3가지는 `정의`, `조작`, `제어`기능이다.

DBMS의 궁극적인 목표는 종속성을 제거하여 `독립성`을 지키는 것이다.

데이터 `정의어` : 테이블이나 제약사항 등을 변경할 때 사용

데이터 `조작어` : 데이터를 실제로 처리하는데 사용

데이터 `제어어` : 권한, 보안, 백업 등을 정의하는데 사용

`트랜잭션` : 한꺼번에 수행되어야 하는 작업(연산)의 단위 (모음)

트랜잭션 실행 중, 오류가 나면 `롤백`을 실행하여 이전 상태로 되돌리고, 전부 완료되었다면 `커밋`을 실행하여 결과를 실제로 반영한다.

절차형 SQL을 `블록 구조`로 되어 있어 기능별 모듈화가 가능하다.

프로시저와 사용자 정의 함수의 차이는 `리턴 값의 필수 여부`이다.

디버깅은 `주석과 출력문`을 이용하는 것이 일반적이다.

---
